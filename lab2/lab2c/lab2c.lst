   1               		.file	"lab2c.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.startup,"ax",@progbits
  11               	.global	main
  13               	main:
  14               	.LFB6:
  15               		.file 1 "lab2c.c"
   1:lab2c.c       **** #include <avr/io.h>
   2:lab2c.c       **** #include <util/delay.h>
   3:lab2c.c       **** #include <avr/cpufunc.h>
   4:lab2c.c       **** 
   5:lab2c.c       **** /*
   6:lab2c.c       **** 
   7:lab2c.c       **** Assignment:
   8:lab2c.c       **** 
   9:lab2c.c       **** Write a C program that uses the 8 LEDs as a number display and 3 DIP switches as input. The
  10:lab2c.c       **** program should read in the state of the 3 DIP switches as a binary number where SW1_1 is the
  11:lab2c.c       **** most significant bit and SW1_3 is the least significant bit.
  12:lab2c.c       **** 
  13:lab2c.c       **** For example if SW1_1 = ON, SW1_2 = ON, SW1_3 = OFF then the number
  14:lab2c.c       **** interpreted by the program should be 0b00000110 = 6
  15:lab2c.c       **** 
  16:lab2c.c       **** In this program the 8 LEDs will not be display the binary representation of the number read from
  17:lab2c.c       **** the DIP switches. Instead the number read in from the DIP switches should be represented by the
  18:lab2c.c       **** number of LEDs that is lit up. For example if the DIP switches is set to 0b000000011, 3 LEDs
  19:lab2c.c       **** should be lit up.
  20:lab2c.c       **** 
  21:lab2c.c       **** Connection Diagram:
  22:lab2c.c       **** 
  23:lab2c.c       **** Atmega328p | Romeo board | IO Board | Jumper Component
  24:lab2c.c       **** 
  25:lab2c.c       **** 	PD2    |     D2      |  JP3_1   | 	D1A  
  26:lab2c.c       **** 	PD3    |     D3      |  JP3_2   | 	D1B  
  27:lab2c.c       **** 	PD4    |     D4      |  JP3_3   | 	D1C
  28:lab2c.c       **** 	PD5    |     D5      |  JP3_4   | 	D1D  
  29:lab2c.c       **** 	PD6    |     D6      |  JP3_5   | 	D1E  
  30:lab2c.c       **** 	PD7    |     D7      |  JP3_6   | 	D1F 
  31:lab2c.c       **** 	PB0    |     D8      |  JP3_7   | 	D1G  
  32:lab2c.c       **** 	PB1    |     D9      |  JP3_8   | 	D1H
  33:lab2c.c       **** 	PB2    |     D10     |  JP2_5   | 	S1  
  34:lab2c.c       **** 	PB3    |     D11     |  JP2_6   | 	S2
  35:lab2c.c       **** 	PB4    |     D12     |  JP2_7   | 	S3
  36:lab2c.c       **** 
  37:lab2c.c       **** */
  38:lab2c.c       **** 
  39:lab2c.c       **** /*********************************************
  40:lab2c.c       **** 	Macros
  41:lab2c.c       **** **********************************************/
  42:lab2c.c       **** 
  43:lab2c.c       **** #define MIN 0U
  44:lab2c.c       **** #define MAX 255U
  45:lab2c.c       **** #define F_CPU 16000000UL
  46:lab2c.c       **** 
  47:lab2c.c       **** 
  48:lab2c.c       **** /*********************************************
  49:lab2c.c       **** 	Local Function Declaration
  50:lab2c.c       **** **********************************************/
  51:lab2c.c       **** 
  52:lab2c.c       **** static void delay_us (uint16_t us);
  53:lab2c.c       **** static void update_leds(uint8_t bits[]);
  54:lab2c.c       **** static void update_bit_array(uint8_t bits[], int lim, uint8_t val);
  55:lab2c.c       **** /*********************************************
  56:lab2c.c       **** 	Main Function
  57:lab2c.c       **** **********************************************/
  58:lab2c.c       **** 
  59:lab2c.c       **** int main(int argc, char const *argv[])
  60:lab2c.c       **** {
  16               		.loc 1 60 0
  17               		.cfi_startproc
  18               	.LVL0:
  19 0000 CF93      		push r28
  20               	.LCFI0:
  21               		.cfi_def_cfa_offset 3
  22               		.cfi_offset 28, -2
  23 0002 DF93      		push r29
  24               	.LCFI1:
  25               		.cfi_def_cfa_offset 4
  26               		.cfi_offset 29, -3
  27 0004 CDB7      		in r28,__SP_L__
  28 0006 DEB7      		in r29,__SP_H__
  29               	.LCFI2:
  30               		.cfi_def_cfa_register 28
  31 0008 2997      		sbiw r28,9
  32               	.LCFI3:
  33               		.cfi_def_cfa_offset 13
  34 000a 0FB6      		in __tmp_reg__,__SREG__
  35 000c F894      		cli
  36 000e DEBF      		out __SP_H__,r29
  37 0010 0FBE      		out __SREG__,__tmp_reg__
  38 0012 CDBF      		out __SP_L__,r28
  39               	/* prologue: function */
  40               	/* frame size = 9 */
  41               	/* stack size = 11 */
  42               	.L__stack_usage = 11
  61:lab2c.c       **** 	//set D2-D7 as output pins
  62:lab2c.c       **** 	DDRD |= ((1 << PD2)| (1 << PD3) | (1 << PD4 ) | ( 1 << PD5 ) | ( 1 << PD6 ) | ( 1 << PD7 )); 
  43               		.loc 1 62 0
  44 0014 8AB1      		in r24,0xa
  45               	.LVL1:
  46 0016 8C6F      		ori r24,lo8(-4)
  47 0018 8AB9      		out 0xa,r24
  63:lab2c.c       **** 	//set B0 and B1 as output pins
  64:lab2c.c       **** 	DDRB |= ((1 << PB0) | (1 << PB1));
  48               		.loc 1 64 0
  49 001a 84B1      		in r24,0x4
  50 001c 8360      		ori r24,lo8(3)
  51 001e 84B9      		out 0x4,r24
  65:lab2c.c       **** 
  66:lab2c.c       **** 	//set B2 and B3 as input pins 
  67:lab2c.c       **** 	DDRB &=~((1 << PB2) | (1 << PB3) | (1 << PB4));
  52               		.loc 1 67 0
  53 0020 84B1      		in r24,0x4
  54 0022 837E      		andi r24,lo8(-29)
  55 0024 84B9      		out 0x4,r24
  68:lab2c.c       **** 	//set up pull-up resistors
  69:lab2c.c       **** 	PORTB |=((1 << PB2) | (1 << PB3) | (1 << PB4));
  56               		.loc 1 69 0
  57 0026 85B1      		in r24,0x5
  58 0028 8C61      		ori r24,lo8(28)
  59 002a 85B9      		out 0x5,r24
  70:lab2c.c       **** 
  71:lab2c.c       **** 	uint8_t bits[] = {0,0,0,0,0,0,0,0};
  60               		.loc 1 71 0
  61 002c FE01      		movw r30,r28
  62 002e 3196      		adiw r30,1
  63 0030 88E0      		ldi r24,lo8(8)
  64 0032 DF01      		movw r26,r30
  65               		0:
  66 0034 1D92      		st X+,__zero_reg__
  67 0036 8A95      		dec r24
  68 0038 01F4      		brne 0b
  69               	.LVL2:
  70 003a 41E0      		ldi r20,lo8(1)
  71               	.LBB16:
  72               	.LBB17:
  72:lab2c.c       **** 	volatile uint8_t input;
  73:lab2c.c       **** 	int sum = 0;
  74:lab2c.c       **** 
  75:lab2c.c       **** 	while(1){
  76:lab2c.c       **** 
  77:lab2c.c       **** 		_NOP();
  78:lab2c.c       **** 		input = PINB;
  79:lab2c.c       **** 
  80:lab2c.c       **** 		sum += ((input >> 4) & 0b00000001) ? 0 : 1; //press S1
  81:lab2c.c       **** 		sum += ((input >> 3) & 0b00000001) ? 0 : 2; //press S2
  82:lab2c.c       **** 		sum += ((input >> 2) & 0b00000001) ? 0 : 4; //press S3
  83:lab2c.c       **** 
  84:lab2c.c       **** 		update_bit_array(bits, sum, 1);
  85:lab2c.c       **** 		update_leds(bits);
  86:lab2c.c       **** 		update_bit_array(bits, sum, 0);
  87:lab2c.c       **** 		
  88:lab2c.c       **** 		sum = 0;
  89:lab2c.c       **** 	}
  90:lab2c.c       **** }
  91:lab2c.c       **** 
  92:lab2c.c       **** 
  93:lab2c.c       **** /*********************************************
  94:lab2c.c       **** 	Local Function Definition
  95:lab2c.c       **** **********************************************/
  96:lab2c.c       **** 
  97:lab2c.c       **** static void update_bit_array(uint8_t bits[], int lim, uint8_t val){
  98:lab2c.c       **** 
  99:lab2c.c       **** 	int i;
 100:lab2c.c       **** 	for(i=0;i<lim;i++){
 101:lab2c.c       **** 		bits[i] = val;
 102:lab2c.c       **** 	}
 103:lab2c.c       **** }
 104:lab2c.c       **** 
 105:lab2c.c       **** static void update_leds(uint8_t bits[]){
 106:lab2c.c       **** 
 107:lab2c.c       **** 	PORTD = 0b00000000;
 108:lab2c.c       **** 	PORTB = 0b00011100; //need to ensure that pull-up resistors are always set.
  73               		.loc 1 108 0
  74 003c 5CE1      		ldi r21,lo8(28)
  75               	.LVL3:
  76               	.L10:
  77               	.LBE17:
  78               	.LBE16:
  77:lab2c.c       **** 		_NOP();
  79               		.loc 1 77 0
  80               	/* #APP */
  81               	 ;  77 "lab2c.c" 1
  82 003e 0000      		nop
  83               	 ;  0 "" 2
  78:lab2c.c       **** 		input = PINB;
  84               		.loc 1 78 0
  85               	/* #NOAPP */
  86 0040 83B1      		in r24,0x3
  87 0042 8987      		std Y+9,r24
  80:lab2c.c       **** 		sum += ((input >> 4) & 0b00000001) ? 0 : 1; //press S1
  88               		.loc 1 80 0
  89 0044 2985      		ldd r18,Y+9
  90 0046 2295      		swap r18
  91 0048 2170      		andi r18,1
  92 004a 2427      		eor r18,r20
  93 004c 30E0      		ldi r19,0
  94               	.LVL4:
  81:lab2c.c       **** 		sum += ((input >> 3) & 0b00000001) ? 0 : 2; //press S2
  95               		.loc 1 81 0
  96 004e 8985      		ldd r24,Y+9
  97 0050 83FF      		sbrs r24,3
  98 0052 00C0      		rjmp .L11
  99 0054 80E0      		ldi r24,0
 100 0056 90E0      		ldi r25,0
 101 0058 00C0      		rjmp .L2
 102               	.L11:
 103 005a 82E0      		ldi r24,lo8(2)
 104 005c 90E0      		ldi r25,0
 105               	.L2:
  81:lab2c.c       **** 		sum += ((input >> 3) & 0b00000001) ? 0 : 2; //press S2
 106               		.loc 1 81 0 is_stmt 0 discriminator 3
 107 005e 280F      		add r18,r24
 108 0060 391F      		adc r19,r25
 109               	.LVL5:
  82:lab2c.c       **** 		sum += ((input >> 2) & 0b00000001) ? 0 : 4; //press S3
 110               		.loc 1 82 0 is_stmt 1 discriminator 3
 111 0062 8985      		ldd r24,Y+9
 112 0064 82FF      		sbrs r24,2
 113 0066 00C0      		rjmp .L12
  82:lab2c.c       **** 		sum += ((input >> 2) & 0b00000001) ? 0 : 4; //press S3
 114               		.loc 1 82 0 is_stmt 0
 115 0068 80E0      		ldi r24,0
 116 006a 90E0      		ldi r25,0
 117 006c 00C0      		rjmp .L3
 118               	.L12:
 119 006e 84E0      		ldi r24,lo8(4)
 120 0070 90E0      		ldi r25,0
 121               	.L3:
  82:lab2c.c       **** 		sum += ((input >> 2) & 0b00000001) ? 0 : 4; //press S3
 122               		.loc 1 82 0 discriminator 3
 123 0072 280F      		add r18,r24
 124 0074 391F      		adc r19,r25
 125               	.LVL6:
 126 0076 DF01      		movw r26,r30
 127               	.LVL7:
 128               	.L4:
 129 0078 CD01      		movw r24,r26
 130 007a 8E1B      		sub r24,r30
 131 007c 9F0B      		sbc r25,r31
 132               	.LBB23:
 133               	.LBB24:
 100:lab2c.c       **** 	for(i=0;i<lim;i++){
 134               		.loc 1 100 0 is_stmt 1
 135 007e 8217      		cp r24,r18
 136 0080 9307      		cpc r25,r19
 137 0082 04F4      		brge .L14
 101:lab2c.c       **** 		bits[i] = val;
 138               		.loc 1 101 0
 139 0084 4D93      		st X+,r20
 140 0086 00C0      		rjmp .L4
 141               	.L14:
 142               	.LBE24:
 143               	.LBE23:
 144               	.LBB25:
 145               	.LBB22:
 107:lab2c.c       **** 	PORTD = 0b00000000;
 146               		.loc 1 107 0
 147 0088 1BB8      		out 0xb,__zero_reg__
 148               		.loc 1 108 0
 149 008a 55B9      		out 0x5,r21
 150               	.LVL8:
 151 008c 8AE0      		ldi r24,lo8(10)
 152 008e 90E0      		ldi r25,0
 153               	.LVL9:
 154               	.L7:
 155               	.LBB18:
 156               	.LBB19:
 157               	.LBB20:
 158               	.LBB21:
 159               		.file 2 "/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h"
   1:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   6:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
   9:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  12:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      distribution.
  16:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  17:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  21:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  33:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  35:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  38:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  41:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  42:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  46:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \file */
  47:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \code
  49:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \endcode
  53:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  54:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     used.
  58:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  59:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  68:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  77:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  81:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** */
  82:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  83:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  87:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  88:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  93:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  94:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
  97:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
  98:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
 103:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 104:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /**
 105:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 107:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 109:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 112:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 114:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 120:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 125:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 129:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 132:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 140:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  */
 141:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** void
 142:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** {
 144:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 152:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 155:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 158:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#else
 159:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//round up by default
 160:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#endif
 162:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 163:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 165:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #else
 166:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	{
 172:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		{
 176:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		}
 180:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		return;
 181:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	}
 182:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	else
 183:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #endif
 186:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** }
 187:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 188:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** /**
 189:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 191:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 193:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 196:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 198:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 202:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   
 207:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 211:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  
 214:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 222:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****  */
 223:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** void
 224:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** {
 226:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 234:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 237:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 240:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#else
 241:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		//round up by default
 242:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	#endif
 244:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 
 245:/usr/local/CrossPack-AVR-20131216/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 160               		.loc 2 245 0
 161 0090 B5E0      		ldi r27,lo8(5)
 162 0092 BA95      		1: dec r27
 163 0094 01F4      		brne 1b
 164 0096 0000      		nop
 165               	.LVL10:
 166 0098 0197      		sbiw r24,1
 167               	.LVL11:
 168               	.LBE21:
 169               	.LBE20:
 109:lab2c.c       **** 	
 110:lab2c.c       **** 	delay_us(10);
 111:lab2c.c       **** 	PORTD |= ((bits[0] << PD2) | (bits[1] << PD3) | (bits[2] << PD4) | (bits[3] << PD5) | (bits[4] << 
 112:lab2c.c       **** 	PORTB |= ((bits[6] << PB0) | (bits[7] << PB1));
 113:lab2c.c       **** 	
 114:lab2c.c       **** 	return;
 115:lab2c.c       **** }
 116:lab2c.c       **** 
 117:lab2c.c       **** static void delay_us (uint16_t us) {
 118:lab2c.c       **** 	uint16_t i;
 119:lab2c.c       **** 	
 120:lab2c.c       **** 	for (i = 0; i < us; i++)
 170               		.loc 1 120 0
 171 009a 0097      		sbiw r24,0
 172 009c 01F4      		brne .L7
 173               	.LBE19:
 174               	.LBE18:
 111:lab2c.c       **** 	PORTD |= ((bits[0] << PD2) | (bits[1] << PD3) | (bits[2] << PD4) | (bits[3] << PD5) | (bits[4] << 
 175               		.loc 1 111 0
 176 009e ABB1      		in r26,0xb
 177 00a0 6981      		ldd r22,Y+1
 178 00a2 84E0      		ldi r24,lo8(4)
 179               	.LVL12:
 180 00a4 689F      		mul r22,r24
 181 00a6 B001      		movw r22,r0
 182 00a8 1124      		clr __zero_reg__
 183 00aa 8A81      		ldd r24,Y+2
 184 00ac B8E0      		ldi r27,lo8(8)
 185 00ae 8B9F      		mul r24,r27
 186 00b0 C001      		movw r24,r0
 187 00b2 1124      		clr __zero_reg__
 188 00b4 682B      		or r22,r24
 189 00b6 6A2B      		or r22,r26
 190 00b8 8B81      		ldd r24,Y+3
 191 00ba 70E1      		ldi r23,lo8(16)
 192 00bc 879F      		mul r24,r23
 193 00be C001      		movw r24,r0
 194 00c0 1124      		clr __zero_reg__
 195 00c2 682B      		or r22,r24
 196 00c4 8C81      		ldd r24,Y+4
 197 00c6 A0E2      		ldi r26,lo8(32)
 198 00c8 8A9F      		mul r24,r26
 199 00ca C001      		movw r24,r0
 200 00cc 1124      		clr __zero_reg__
 201 00ce 682B      		or r22,r24
 202 00d0 8D81      		ldd r24,Y+5
 203 00d2 B0E4      		ldi r27,lo8(64)
 204 00d4 8B9F      		mul r24,r27
 205 00d6 C001      		movw r24,r0
 206 00d8 1124      		clr __zero_reg__
 207 00da 682B      		or r22,r24
 208 00dc 8E81      		ldd r24,Y+6
 209 00de 70E8      		ldi r23,lo8(-128)
 210 00e0 879F      		mul r24,r23
 211 00e2 C001      		movw r24,r0
 212 00e4 1124      		clr __zero_reg__
 213 00e6 682B      		or r22,r24
 214 00e8 6BB9      		out 0xb,r22
 112:lab2c.c       **** 	PORTB |= ((bits[6] << PB0) | (bits[7] << PB1));
 215               		.loc 1 112 0
 216 00ea 95B1      		in r25,0x5
 217 00ec 8F81      		ldd r24,Y+7
 218 00ee 982B      		or r25,r24
 219 00f0 8885      		ldd r24,Y+8
 220 00f2 880F      		lsl r24
 221 00f4 892B      		or r24,r25
 222 00f6 85B9      		out 0x5,r24
 223               	.LVL13:
 224 00f8 DF01      		movw r26,r30
 225               	.LVL14:
 226               	.L8:
 227 00fa CD01      		movw r24,r26
 228 00fc 8E1B      		sub r24,r30
 229 00fe 9F0B      		sbc r25,r31
 230               	.LBE22:
 231               	.LBE25:
 232               	.LBB26:
 233               	.LBB27:
 100:lab2c.c       **** 	for(i=0;i<lim;i++){
 234               		.loc 1 100 0
 235 0100 8217      		cp r24,r18
 236 0102 9307      		cpc r25,r19
 237 0104 04F0      		brlt .+2
 238 0106 00C0      		rjmp .L10
 101:lab2c.c       **** 		bits[i] = val;
 239               		.loc 1 101 0
 240 0108 1D92      		st X+,__zero_reg__
 241 010a 00C0      		rjmp .L8
 242               	.LBE27:
 243               	.LBE26:
 244               		.cfi_endproc
 245               	.LFE6:
 247               		.text
 248               	.Letext0:
 249               		.file 3 "/usr/local/CrossPack-AVR-20131216/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:00000000 lab2c.c
/var/folders/y1/ytk3559n6_95s3fkjf945z6r0000gn/T//ccYy74fL.s:2      *ABS*:0000003e __SP_H__
/var/folders/y1/ytk3559n6_95s3fkjf945z6r0000gn/T//ccYy74fL.s:3      *ABS*:0000003d __SP_L__
/var/folders/y1/ytk3559n6_95s3fkjf945z6r0000gn/T//ccYy74fL.s:4      *ABS*:0000003f __SREG__
/var/folders/y1/ytk3559n6_95s3fkjf945z6r0000gn/T//ccYy74fL.s:5      *ABS*:00000000 __tmp_reg__
/var/folders/y1/ytk3559n6_95s3fkjf945z6r0000gn/T//ccYy74fL.s:6      *ABS*:00000001 __zero_reg__
/var/folders/y1/ytk3559n6_95s3fkjf945z6r0000gn/T//ccYy74fL.s:13     .text.startup:00000000 main

NO UNDEFINED SYMBOLS
